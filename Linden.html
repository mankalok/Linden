<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å››é‚Šå½¢å­¸ç¿’éŠæˆ²</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#FF6B6B',
            secondary: '#4ECDC4',
            accent: '#FFD166',
            happy: '#6A0572',
            playful: '#9775fa',
            joyful: '#33d9b2'
          },
        },
      },
      darkMode: 'class',
    }
  </script>
  <style>
    body {
      font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
      touch-action: manipulation;
      background-image: radial-gradient(#fff8e8 1px, transparent 1px), radial-gradient(#fff8e8 1px, transparent 1px);
      background-size: 20px 20px;
      background-position: 0 0, 10px 10px;
    }
    
    /* æ·±è‰²æ¨¡å¼ */
    .dark {
      color-scheme: dark;
    }
    
    .dark body {
      background-color: #1e1e2e;
      color: #fff;
      background-image: radial-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px), radial-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px);
    }
    
    .bounce {
      animation: bounce 0.5s;
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    .pulse {
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .wiggle {
      animation: wiggle 1s ease-in-out;
    }
    
    @keyframes wiggle {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-5deg); }
      75% { transform: rotate(5deg); }
    }
    
    .float {
      animation: float 3s ease-in-out infinite;
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-6px); }
    }
    
    /* SVG é‚Šç·£çš„æ‡¸åœæ•ˆæœ */
    .edge:hover {
      stroke-width: 8;
      cursor: pointer;
      filter: drop-shadow(0 0 4px rgba(255, 107, 107, 0.6));
      transition: all 0.2s ease;
    }
    
    .rainbow-text {
      background-image: linear-gradient(90deg, #FF6B6B, #FFD166, #4ECDC4, #9775fa, #33d9b2);
      background-clip: text;
      -webkit-background-clip: text;
      color: transparent;
      animation: rainbow 8s ease infinite;
      background-size: 400% 100%;
    }
    
    @keyframes rainbow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    .btn-hover-effect:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body class="p-4 md:p-6 bg-white dark:bg-gray-900 min-h-screen">
  <!-- æª¢æ¸¬æš—æ¨¡å¼ -->
  <script>
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      document.documentElement.classList.add('dark');
    }
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
      if (event.matches) {
        document.documentElement.classList.add('dark');
      } else {
        document.documentElement.classList.remove('dark');
      }
    });
  </script>

  <div class="max-w-3xl mx-auto">
    <h1 class="text-3xl md:text-4xl font-bold text-center rainbow-text mb-2">âœ¨ å››é‚Šå½¢å­¸ç¿’éŠæˆ² âœ¨</h1>
    <p class="text-center text-secondary dark:text-secondary mb-4 float">è®“æˆ‘å€‘ä¸€èµ·å­¸ç¿’å››é‚Šå½¢çš„é‚Šå§ï¼ğŸ‘§ğŸ‘¦</p>
    
    <!-- éŠæˆ²æ¨¡å¼é¸æ“‡ -->
    <div class="flex justify-center gap-4 mb-6">
      <button id="oppositeEdgeBtn" class="btn-hover-effect py-3 px-6 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 text-lg font-bold hover:bg-gray-300 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 transform transition duration-300">ğŸ”„ æ‰¾å°é‚Š</button>
      <button id="adjacentEdgeBtn" class="btn-hover-effect py-3 px-6 rounded-full bg-accent dark:bg-accent text-white text-lg font-bold hover:bg-yellow-500 dark:hover:bg-yellow-500 focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-offset-2 transform transition duration-300">ğŸ‘­ æ‰¾é„°é‚Š</button>
    </div>
    
    <!-- éŠæˆ²èªªæ˜ -->
    <div id="gameInstruction" class="text-lg text-center mb-4 text-happy dark:text-playful font-medium">
      ğŸ” åœ¨æ¯å€‹å››é‚Šå½¢ä¸­ï¼Œæ‰¾å‡ºé„°é‚Šï¼ˆå…±ç”¨ä¸€å€‹é ‚é»çš„å…©æ¢é‚Šï¼‰
    </div>
    
    <!-- å››é‚Šå½¢é¡¯ç¤ºå€åŸŸ -->
    <div id="quadrilateralContainer" class="bg-white dark:bg-gray-800 rounded-xl p-4 mb-6 shadow-lg border-2 border-accent dark:border-secondary">
      <div id="quadrilateralsGrid" class="grid gap-4 w-full h-full">
        <div class="flex items-center justify-center">
          <svg id="quadrilateralSvg0" class="quadrilateralSvg" width="100%" height="100%" viewBox="0 0 300 300"></svg>
        </div>
      </div>
    </div>
    
    <!-- åé¥‹ä¿¡æ¯ -->
    <div id="feedback" class="text-lg text-center mb-6 min-h-16 text-gray-700 dark:text-gray-300 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
      ğŸ‘† è«‹é»é¸å››é‚Šå½¢çš„ä¸€æ¢é‚Šé–‹å§‹éŠæˆ²ï¼
    </div>
    
    <!-- æ§åˆ¶æŒ‰éˆ• -->
    <div class="flex justify-center">
      <button id="nextBtn" class="btn-hover-effect py-3 px-6 rounded-full bg-primary dark:bg-primary text-white text-xl font-bold hover:bg-red-500 dark:hover:bg-red-500 focus:outline-none focus:ring-2 focus:ring-red-400 focus:ring-offset-2 transform transition duration-300 pulse">ğŸ® ä¸‹ä¸€å€‹å››é‚Šå½¢</button>
    </div>
    
    <!-- åº•éƒ¨è£é£¾ -->
    <div class="mt-8 text-center text-sm text-gray-500 dark:text-gray-400">
      <p>â¤ï¸ å­¸ç¿’æ•¸å­¸çœŸæœ‰è¶£ â¤ï¸</p>
    </div>
  </div>

  <script>
    // éŠæˆ²ç‹€æ…‹
    const gameState = {
      mode: 'adjacent', // 'opposite' æˆ– 'adjacent'
      selectedEdgeIndex: null,
      selectedQuadIndex: null,
      quadrilateral: null,
      edgeColors: ['#FF6B6B', '#4ECDC4', '#FFD166', '#6A0572', '#9775fa', '#33d9b2'],
      currentColorIndex: 0,
      // æ¯å€‹å››é‚Šå½¢çš„é…å°ç‹€æ…‹
      quadrilaterals: [
        { correctPairs: [] },
        { correctPairs: [] },
        { correctPairs: [] },
        { correctPairs: [] }
      ],
      // ç¸½å…±å®Œæˆçš„é…å°æ•¸
      totalCompletedPairs: 0,
      // éœ€è¦å®Œæˆçš„ç¸½é…å°æ•¸
      totalRequiredPairs: 4
    };
    
    // DOM å…ƒç´ å¼•ç”¨
    const quadrilateralsGrid = document.getElementById('quadrilateralsGrid');
    const feedbackEl = document.getElementById('feedback');
    const oppositeEdgeBtn = document.getElementById('oppositeEdgeBtn');
    const adjacentEdgeBtn = document.getElementById('adjacentEdgeBtn');
    const nextBtn = document.getElementById('nextBtn');
    const gameInstruction = document.getElementById('gameInstruction');
    
    // é»æ“Šæ¨¡å¼æŒ‰éˆ•
    oppositeEdgeBtn.addEventListener('click', () => {
      setGameMode('opposite');
    });
    
    adjacentEdgeBtn.addEventListener('click', () => {
      setGameMode('adjacent');
    });
    
    // é»æ“Šä¸‹ä¸€å€‹æŒ‰éˆ•
    nextBtn.addEventListener('click', () => {
      gameState.selectedEdgeIndex = null;
      gameState.selectedQuadIndex = null;
      gameState.totalCompletedPairs = 0;
      
      // é‡ç½®æ‰€æœ‰å››é‚Šå½¢çš„é…å°ç‹€æ…‹
      gameState.quadrilaterals = gameState.quadrilaterals.map(() => ({ correctPairs: [] }));
      
      // é‡å»ºæ‰€æœ‰å››é‚Šå½¢
      createQuadrilaterals();
      
      feedbackEl.textContent = 'è«‹é»é¸å››é‚Šå½¢çš„ä¸€æ¢é‚Šé–‹å§‹éŠæˆ²ï¼';
      feedbackEl.className = 'text-lg text-center mb-6 min-h-16 text-gray-700 dark:text-gray-300';
    });
    
    // è¨­ç½®éŠæˆ²æ¨¡å¼
    function setGameMode(mode) {
      gameState.mode = mode;
      gameState.totalCompletedPairs = 0;
      
      if (mode === 'opposite') {
        oppositeEdgeBtn.classList.add('bg-primary', 'dark:bg-indigo-600');
        oppositeEdgeBtn.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800');
        oppositeEdgeBtn.classList.add('text-white');
        
        adjacentEdgeBtn.classList.remove('bg-primary', 'dark:bg-indigo-600');
        adjacentEdgeBtn.classList.add('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800');
        adjacentEdgeBtn.classList.remove('text-white');
        
        gameInstruction.textContent = 'åœ¨æ¯å€‹å››é‚Šå½¢ä¸­ï¼Œæ‰¾å‡ºå°é‚Šï¼ˆç›¸å°ã€ä¸å…±ç”¨é ‚é»çš„å…©æ¢é‚Šï¼‰';
        
        // å°é‚Šæ¨¡å¼ï¼šé¡¯ç¤º2å€‹å››é‚Šå½¢ï¼ˆå› ç‚ºæœ‰2å°å°é‚Šï¼‰
        gameState.totalRequiredPairs = 2;
        gameState.quadrilaterals = Array(2).fill().map(() => ({ correctPairs: [] }));
        
        // è¨­ç½®ç¶²æ ¼ç‚º 1x2 (ä¸€è¡Œå…©å€‹å››é‚Šå½¢)
        quadrilateralsGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4 w-full';
      } else {
        adjacentEdgeBtn.classList.add('bg-primary', 'dark:bg-indigo-600');
        adjacentEdgeBtn.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800');
        adjacentEdgeBtn.classList.add('text-white');
        
        oppositeEdgeBtn.classList.remove('bg-primary', 'dark:bg-indigo-600');
        oppositeEdgeBtn.classList.add('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800');
        oppositeEdgeBtn.classList.remove('text-white');
        
        gameInstruction.textContent = 'åœ¨æ¯å€‹å››é‚Šå½¢ä¸­ï¼Œæ‰¾å‡ºé„°é‚Šï¼ˆå…±ç”¨ä¸€å€‹é ‚é»çš„å…©æ¢é‚Šï¼‰';
        
        // é„°é‚Šæ¨¡å¼ï¼šé¡¯ç¤º4å€‹å››é‚Šå½¢ï¼ˆå› ç‚ºæœ‰4å°é„°é‚Šï¼‰
        gameState.totalRequiredPairs = 4;
        gameState.quadrilaterals = Array(4).fill().map(() => ({ correctPairs: [] }));
        
        // è¨­ç½®ç¶²æ ¼ç‚º 2x2 (å…©è¡Œå…©å€‹å››é‚Šå½¢)
        quadrilateralsGrid.className = 'grid grid-cols-1 sm:grid-cols-2 gap-4 w-full';
      }
      
      // é‡ç½®æ¸¸æˆçŠ¶æ€
      gameState.selectedEdgeIndex = null;
      gameState.selectedQuadIndex = null;
      feedbackEl.textContent = 'è«‹é»é¸å››é‚Šå½¢çš„ä¸€æ¢é‚Šé–‹å§‹éŠæˆ²ï¼';
      feedbackEl.className = 'text-lg text-center mb-6 min-h-16 text-gray-700 dark:text-gray-300';
      
      // é‡å»ºå››é‚Šå½¢å®¹å™¨
      createQuadrilaterals();
    }
    
    // å‰µå»ºæ‰€æœ‰å››é‚Šå½¢
    function createQuadrilaterals() {
      // æ¸…ç©ºå››é‚Šå½¢ç¶²æ ¼
      quadrilateralsGrid.innerHTML = '';
      
      // éš¨æ©Ÿé¸æ“‡ä¸€ç¨®å››é‚Šå½¢é¡å‹ï¼Œæ‰€æœ‰å››é‚Šå½¢ä½¿ç”¨ç›¸åŒé¡å‹
      const types = ['square', 'rectangle', 'parallelogram', 'trapezoid', 'rhombus'];
      const type = types[Math.floor(Math.random() * types.length)];
      
      // å‰µå»ºæ‰€éœ€æ•¸é‡çš„å››é‚Šå½¢
      const numQuadrilaterals = gameState.quadrilaterals.length;
      
      // å…ˆç”Ÿæˆä¸€å€‹å››é‚Šå½¢çš„é»ï¼Œä»¥ä¾¿è¤‡è£½åˆ°æ‰€æœ‰å¯¦ä¾‹
      let sharedPoints = generateQuadrilateralPoints(type);
      
      // ä¿å­˜å…±äº«çš„å››é‚Šå½¢åæ¨™åˆ°éŠæˆ²ç‹€æ…‹
      gameState.sharedPoints = sharedPoints;
      
      // ç‚ºæ¯å€‹å››é‚Šå½¢å‰µå»ºä¸€å€‹SVGå®¹å™¨
      for (let q = 0; q < numQuadrilaterals; q++) {
        const quadContainer = document.createElement('div');
        quadContainer.className = 'flex items-center justify-center bg-white dark:bg-gray-800 rounded-lg p-2 aspect-square';
        quadContainer.style.height = gameState.mode === 'opposite' ? '280px' : '240px';
        
        const svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svgElement.id = `quadrilateralSvg${q}`;
        svgElement.className = 'quadrilateralSvg';
        svgElement.setAttribute('width', '100%');
        svgElement.setAttribute('height', '100%');
        svgElement.setAttribute('viewBox', '0 0 300 300');
        
        quadContainer.appendChild(svgElement);
        quadrilateralsGrid.appendChild(quadContainer);
        
        // å‰µå»ºå››é‚Šå½¢ - ä½¿ç”¨å…±äº«çš„é»
        createSingleQuadrilateral(svgElement, type, q, sharedPoints);
      }
      
      // ä¿å­˜å››é‚Šå½¢é¡å‹
      gameState.quadrilateralType = type;
    }
    
    // ç”Ÿæˆå››é‚Šå½¢çš„é»
    function generateQuadrilateralPoints(type) {
      let points = [];
      
      // ä¸­å¿ƒé»å’Œç›¸å°å°ºå¯¸
      const centerX = 150;
      const centerY = 150;
      const size = 100;
      
      // æ ¹æ“šé¡å‹ç”Ÿæˆé»
      switch (type) {
        case 'square':
          points = [
            [centerX - size/2, centerY - size/2],
            [centerX + size/2, centerY - size/2],
            [centerX + size/2, centerY + size/2],
            [centerX - size/2, centerY + size/2]
          ];
          break;
          
        case 'rectangle':
          const width = size * 1.5;
          const height = size * 0.8;
          points = [
            [centerX - width/2, centerY - height/2],
            [centerX + width/2, centerY - height/2],
            [centerX + width/2, centerY + height/2],
            [centerX - width/2, centerY + height/2]
          ];
          break;
          
        case 'parallelogram':
          const offset = size * 0.5;
          points = [
            [centerX - size/2 + offset, centerY - size/2],
            [centerX + size/2 + offset, centerY - size/2],
            [centerX + size/2 - offset, centerY + size/2],
            [centerX - size/2 - offset, centerY + size/2]
          ];
          break;
          
        case 'trapezoid':
          const topWidth = size * 0.6;
          const bottomWidth = size * 1.2;
          points = [
            [centerX - topWidth/2, centerY - size/2],
            [centerX + topWidth/2, centerY - size/2],
            [centerX + bottomWidth/2, centerY + size/2],
            [centerX - bottomWidth/2, centerY + size/2]
          ];
          break;
          
        case 'rhombus':
          // å‰µå»ºè±å½¢ï¼Œæ‰€æœ‰é‚Šé•·ç›¸ç­‰ä½†è§’ä¸æ˜¯ç›´è§’
          const horizontalOffset = size * 0.6;
          const verticalOffset = size * 0.8;
          
          points = [
            [centerX, centerY - verticalOffset], // é ‚é»
            [centerX + horizontalOffset, centerY], // å³é»
            [centerX, centerY + verticalOffset], // åº•é»
            [centerX - horizontalOffset, centerY] // å·¦é»
          ];
          break;
      }
      
      return points;
    }
    
    // å‰µå»ºå–®å€‹å››é‚Šå½¢
    function createSingleQuadrilateral(svgElement, type, quadIndex, sharedPoints) {
      // ä½¿ç”¨å…±äº«çš„é»ï¼Œç¢ºä¿æ‰€æœ‰å››é‚Šå½¢å®Œå…¨ç›¸åŒ
      const points = sharedPoints;
      
      // ç¹ªè£½å››é‚Šå½¢
      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      const pointsStr = points.map(p => p.join(',')).join(' ');
      polygon.setAttribute('points', pointsStr);
      polygon.setAttribute('fill', 'none');
      polygon.setAttribute('stroke', '#aaa');
      polygon.setAttribute('stroke-width', '2');
      svgElement.appendChild(polygon);
      
      // ç¹ªè£½é‚Š
      for (let i = 0; i < 4; i++) {
        const edge = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        edge.setAttribute('x1', points[i][0]);
        edge.setAttribute('y1', points[i][1]);
        edge.setAttribute('x2', points[(i + 1) % 4][0]);
        edge.setAttribute('y2', points[(i + 1) % 4][1]);
        edge.setAttribute('stroke', '#333');
        edge.setAttribute('stroke-width', '4');
        edge.setAttribute('class', 'edge');
        edge.setAttribute('data-index', i);
        edge.setAttribute('data-quad-index', quadIndex);
        edge.addEventListener('click', handleEdgeClick);
        svgElement.appendChild(edge);
      }
      
      // æ·»åŠ å››é‚Šå½¢é¡å‹èªªæ˜å’Œåºè™Ÿ
      const typeNames = {
        square: 'æ­£æ–¹å½¢',
        rectangle: 'é•·æ–¹å½¢',
        parallelogram: 'å¹³è¡Œå››é‚Šå½¢',
        trapezoid: 'æ¢¯å½¢',
        rhombus: 'è±å½¢'
      };
      
      const typeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      typeText.setAttribute('x', '20');
      typeText.setAttribute('y', '30');
      typeText.setAttribute('fill', 'currentColor');
      typeText.setAttribute('class', 'text-lg font-bold');
      typeText.textContent = `${typeNames[type]} #${quadIndex+1}`;
      svgElement.appendChild(typeText);
      
      // å¦‚æœé€™æ˜¯å°é‚Šæ¨¡å¼ï¼Œæ·»åŠ æç¤ºæ¨™ç±¤
      if (gameState.mode === 'opposite') {
        const infoText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        infoText.setAttribute('x', '150');
        infoText.setAttribute('y', '280');
        infoText.setAttribute('text-anchor', 'middle');
        infoText.setAttribute('fill', 'currentColor');
        infoText.setAttribute('class', 'text-sm');
        infoText.textContent = `æ‰¾å‡ºç¬¬${quadIndex + 1}å°å°é‚Š`;
        svgElement.appendChild(infoText);
      } else {
        const infoText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        infoText.setAttribute('x', '150');
        infoText.setAttribute('y', '280');
        infoText.setAttribute('text-anchor', 'middle');
        infoText.setAttribute('fill', 'currentColor');
        infoText.setAttribute('class', 'text-sm');
        infoText.textContent = `æ‰¾å‡ºç¬¬${quadIndex + 1}å°é„°é‚Š`;
        svgElement.appendChild(infoText);
      }
    }
    
    // æ—‹è½¬ç‚¹
    function rotatePoints(points, centerX, centerY, angle) {
      const rad = (angle * Math.PI) / 180;
      return points.map(p => {
        const x = p[0] - centerX;
        const y = p[1] - centerY;
        return [
          centerX + x * Math.cos(rad) - y * Math.sin(rad),
          centerY + x * Math.sin(rad) + y * Math.cos(rad)
        ];
      });
    }
    
    // è™•ç†é‚Šçš„é»æ“Š
    function handleEdgeClick(event) {
      const edge = event.target;
      const edgeIndex = parseInt(edge.getAttribute('data-index'));
      const quadIndex = parseInt(edge.getAttribute('data-quad-index'));
      
      // æª¢æŸ¥é€™æ¢é‚Šæ˜¯å¦å·²ç¶“è¢«é…å°
      for (const pair of gameState.quadrilaterals[quadIndex].correctPairs) {
        if (pair.includes(edgeIndex)) {
          feedbackEl.textContent = 'é€™æ¢é‚Šå·²ç¶“è¢«é¸éäº†ï¼Œè«‹é¸æ“‡å¦ä¸€æ¢é‚Šã€‚';
          return;
        }
      }
      
      // å¦‚æœæœ‰é¸ä¸­çš„é‚Šï¼Œä½†æ˜¯å››é‚Šå½¢ç´¢å¼•ä¸åŒï¼Œå‰‡é‡ç½®é¸æ“‡
      if (gameState.selectedEdgeIndex !== null && gameState.selectedQuadIndex !== quadIndex) {
        // æ‰¾åˆ°ä¹‹å‰é¸ä¸­çš„é‚Š
        const prevSelectedEdge = document.querySelector(`line[data-index="${gameState.selectedEdgeIndex}"][data-quad-index="${gameState.selectedQuadIndex}"]`);
        if (prevSelectedEdge && !isEdgeInCorrectPair(gameState.selectedEdgeIndex, gameState.selectedQuadIndex)) {
          prevSelectedEdge.setAttribute('stroke', '#333');
          prevSelectedEdge.setAttribute('stroke-width', '4');
        }
        gameState.selectedEdgeIndex = null;
        gameState.selectedQuadIndex = null;
      }
      
      // å¦‚æœæ²’æœ‰é¸ä¸­é‚Šï¼Œä¿å­˜ç•¶å‰é¸ä¸­é‚Š
      if (gameState.selectedEdgeIndex === null) {
        gameState.selectedEdgeIndex = edgeIndex;
        gameState.selectedQuadIndex = quadIndex;
        edge.setAttribute('stroke', gameState.edgeColors[gameState.currentColorIndex]);
        edge.setAttribute('stroke-width', '6');
        feedbackEl.textContent = 'ğŸ‘€ å¥½çš„ï¼ç¾åœ¨è«‹é¸æ“‡' + 
          (gameState.mode === 'opposite' ? 'å°é‚Š ğŸ”„' : 'é„°é‚Š ğŸ‘­') + 'ã€‚';
        feedbackEl.classList.add('text-primary', 'dark:text-accent');
      } else {
        // æª¢æŸ¥æ˜¯å¦æ˜¯åŒä¸€æ¢é‚Š
        if (gameState.selectedEdgeIndex === edgeIndex && gameState.selectedQuadIndex === quadIndex) {
          feedbackEl.textContent = 'ğŸ˜… ä½ é¸äº†åŒä¸€æ¢é‚Šï¼Œè«‹é¸æ“‡ä¸åŒçš„é‚Šã€‚';
          feedbackEl.classList.add('text-orange-500', 'dark:text-orange-400');
          return;
        }
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºå°é‚Šæˆ–é„°é‚Š
        let correct = false;
        
        if (gameState.mode === 'opposite') {
          // å°é‚Š: ç´¢å¼•å·®ç‚º2æˆ–-2
          const diff = Math.abs(gameState.selectedEdgeIndex - edgeIndex);
          correct = diff === 2;
        } else {
          // é„°é‚Š: ç´¢å¼•å·®ç‚º1æˆ–3ï¼ˆ0å’Œ3æ˜¯é„°é‚Šï¼‰
          const diff = Math.abs(gameState.selectedEdgeIndex - edgeIndex);
          correct = diff === 1 || diff === 3;
        }
        
        if (correct) {
          // æª¢æŸ¥é€™å°é‚Šæ˜¯å¦å·²ç¶“åœ¨å…¶ä»–å››é‚Šå½¢ä¸­è¢«æ‰¾åˆ°é
          const edgePair = [Math.min(gameState.selectedEdgeIndex, edgeIndex), Math.max(gameState.selectedEdgeIndex, edgeIndex)];
          let pairAlreadyFound = false;
          
          // éæ­·æ‰€æœ‰å·²é…å°çš„å››é‚Šå½¢
          for (let i = 0; i < gameState.quadrilaterals.length; i++) {
            if (i === quadIndex) continue; // è·³éç•¶å‰å››é‚Šå½¢
            
            // æª¢æŸ¥æ¯å€‹å·²é…å°
            for (const pair of gameState.quadrilaterals[i].correctPairs) {
              const existingPair = [Math.min(pair[0], pair[1]), Math.max(pair[0], pair[1])];
              if (existingPair[0] === edgePair[0] && existingPair[1] === edgePair[1]) {
                pairAlreadyFound = true;
                break;
              }
            }
            
            if (pairAlreadyFound) break;
          }
          
          if (pairAlreadyFound) {
            // é€™å°é‚Šå·²ç¶“åœ¨å…¶ä»–å››é‚Šå½¢ä¸­è¢«æ‰¾åˆ°éï¼Œæç¤ºç”¨æˆ¶æ‰¾ä¸åŒçš„é‚Š
            feedbackEl.textContent = 'é€™å°' + (gameState.mode === 'opposite' ? 'å°é‚Š' : 'é„°é‚Š') + 
              'å·²ç¶“åœ¨å¦ä¸€å€‹å››é‚Šå½¢ä¸­è¢«æ‰¾åˆ°éäº†ï¼Œè«‹æ‰¾å‡ºä¸åŒçš„é‚Šå°ï¼';
            feedbackEl.classList.add('text-blue-600', 'dark:text-blue-400');
            
            // é‡ç½®é¸ä¸­çš„é‚Š
            const prevSelectedEdge = document.querySelector(`line[data-index="${gameState.selectedEdgeIndex}"][data-quad-index="${gameState.selectedQuadIndex}"]`);
            if (prevSelectedEdge && !isEdgeInCorrectPair(gameState.selectedEdgeIndex, gameState.selectedQuadIndex)) {
              prevSelectedEdge.setAttribute('stroke', '#333');
              prevSelectedEdge.setAttribute('stroke-width', '4');
            }
            edge.setAttribute('stroke', '#333');
            edge.setAttribute('stroke-width', '4');
            
            // é‡ç½®é¸ä¸­çš„é‚Šç´¢å¼•
            gameState.selectedEdgeIndex = null;
            gameState.selectedQuadIndex = null;
            
            return;
          }
          
          // ç­”å°äº†è€Œä¸”æ˜¯æ–°çš„é…å°
          edge.setAttribute('stroke', gameState.edgeColors[gameState.currentColorIndex]);
          edge.setAttribute('stroke-width', '6');
          
          // ä¿å­˜é€™å°æ­£ç¢ºåŒ¹é…
          gameState.quadrilaterals[quadIndex].correctPairs.push([gameState.selectedEdgeIndex, edgeIndex]);
          
          // å¢åŠ ç¸½å®Œæˆé…å°æ•¸
          gameState.totalCompletedPairs++;
          
          // æº–å‚™ä¸‹ä¸€å°çš„é¡è‰²
          gameState.currentColorIndex = (gameState.currentColorIndex + 1) % gameState.edgeColors.length;
          
          // æº–å‚™çå‹µè¡¨æƒ…ç¬¦è™Ÿ
          const rewardEmojis = ['ğŸ‰', 'ğŸ‘', 'ğŸŒŸ', 'ğŸ˜Š', 'ğŸ†', 'ğŸ’¯', 'ğŸ§ ', 'ğŸ‘', 'ğŸ¤©', 'ğŸ’ª'];
          const randomEmoji = rewardEmojis[Math.floor(Math.random() * rewardEmojis.length)];
          
          // åé¥‹
          feedbackEl.textContent = `${randomEmoji} å¤ªæ£’äº†ï¼ä½ æ‰¾åˆ°äº†æ­£ç¢ºçš„` + 
            (gameState.mode === 'opposite' ? 'å°é‚Š' : 'é„°é‚Š') + 'ï¼' + `${randomEmoji}`;
          feedbackEl.classList.add('text-green-600', 'dark:text-green-400', 'font-bold', 'bounce');
          setTimeout(() => {
            feedbackEl.classList.remove('bounce');
          }, 500);
          
          // æª¢æŸ¥æ˜¯å¦å…¨éƒ¨æ‰¾å®Œ
          if (gameState.totalCompletedPairs === gameState.totalRequiredPairs) {
            setTimeout(() => {
              feedbackEl.innerHTML = 'ğŸŠğŸŠ æ­å–œä½ ï¼ğŸŠğŸŠ<br>å·²æ‰¾å‡ºæ‰€æœ‰' + gameState.totalRequiredPairs + 'å°' + 
                (gameState.mode === 'opposite' ? 'å°é‚Š' : 'é„°é‚Š') + 'ã€‚<br>é»æ“Šã€Œä¸‹ä¸€å€‹å››é‚Šå½¢ã€ç¹¼çºŒï¼';
              feedbackEl.classList.add('wiggle');
              nextBtn.classList.add('animate-bounce');
              setTimeout(() => {
                nextBtn.classList.remove('animate-bounce');
                feedbackEl.classList.remove('wiggle');
              }, 1000);
            }, 1000);
          } else {
            // é‚„æ²’å®Œæˆå…¨éƒ¨é…å°ï¼ŒæŒ‡ç¤ºç”¨æˆ¶ä¸‹ä¸€æ­¥æ“ä½œ
            setTimeout(() => {
              feedbackEl.textContent = `ğŸ”¥ å¤ªå¥½äº†ï¼ä½ å·²å®Œæˆ ${gameState.totalCompletedPairs}/${gameState.totalRequiredPairs} å°é…å°ã€‚ç¹¼çºŒæ‰¾ä¸‹ä¸€å°å§ï¼ â©`;
            }, 1500);
          }
        } else {
          // ç­”éŒ¯äº†
          let explanationText = '';
          
          if (gameState.mode === 'opposite') {
            explanationText = 'å°é‚Šæ˜¯æŒ‡å››é‚Šå½¢ä¸­ç›¸å°çš„å…©æ¢é‚Šï¼Œå®ƒå€‘ä¸å…±ç”¨é ‚é»ã€‚';
          } else {
            explanationText = 'é„°é‚Šæ˜¯æŒ‡å››é‚Šå½¢ä¸­å…±ç”¨ä¸€å€‹é ‚é»çš„å…©æ¢é‚Šã€‚';
          }
          
          const encourageEmojis = ['ğŸ¤”', 'ğŸ˜Š', 'ğŸ’ª', 'âœ¨', 'ğŸ‘€'];
          const randomEncourageEmoji = encourageEmojis[Math.floor(Math.random() * encourageEmojis.length)];
          
          feedbackEl.textContent = `${randomEncourageEmoji} ä¸å¤ªå°å–”ï¼Œä½†åˆ¥ç°å¿ƒï¼` + explanationText + `å†è©¦ä¸€æ¬¡å§ï¼${randomEncourageEmoji}`;
          feedbackEl.classList.add('text-orange-500', 'dark:text-orange-400', 'wiggle');
          
          // é‡ç½®é¸ä¸­çš„é‚Š
          const prevSelectedEdge = document.querySelector(`line[data-index="${gameState.selectedEdgeIndex}"][data-quad-index="${gameState.selectedQuadIndex}"]`);
          if (prevSelectedEdge && !isEdgeInCorrectPair(gameState.selectedEdgeIndex, gameState.selectedQuadIndex)) {
            prevSelectedEdge.setAttribute('stroke', '#333');
            prevSelectedEdge.setAttribute('stroke-width', '4');
          }
        }
        
        // é‡ç½®é¸ä¸­çš„é‚Šç´¢å¼•
        gameState.selectedEdgeIndex = null;
        gameState.selectedQuadIndex = null;
      }
    }
    
    // æª¢æŸ¥é‚Šæ˜¯å¦å·²åœ¨æ­£ç¢ºé…å°ä¸­
    function isEdgeInCorrectPair(edgeIndex, quadIndex) {
      for (const pair of gameState.quadrilaterals[quadIndex].correctPairs) {
        if (pair.includes(edgeIndex)) {
          return true;
        }
      }
      return false;
    }
    
    // åˆå§‹åŒ–æ¸¸æˆ
    // ç¢ºä¿åˆå§‹è¨­ç½®æ­£ç¢ºçš„ç¶²æ ¼ä½ˆå±€
    if (gameState.mode === 'opposite') {
      quadrilateralsGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4 w-full';
    } else {
      quadrilateralsGrid.className = 'grid grid-cols-1 sm:grid-cols-2 gap-4 w-full';
    }
    createQuadrilaterals();
  </script>
</body>
</html>